/*
 * generated by Xtext 2.10.0
 */
package ingraph.cucumber.featureresult.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class FeatureResultsGrammarAccess extends AbstractGrammarElementFinder {
	
	public class FeatureValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.FeatureValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNodeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRelationshipParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cPathParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIntegerParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cMyStringParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cBoolParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cNullValueParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cListParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cMapParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		
		/// *
		// * value : node
		// *  | relationship
		// *  | path
		// *  | integer
		// *  | floatingPoint
		// *  | string
		// *  | bool
		// *  | nullValue
		// *  | list
		// *  | map
		// *  ;
		// * / // renamed 'Value' to 'FeatureValue' to disambiguate it from the Neo4j driver's org.neo4j.driver.v1.Value class
		//FeatureValue:
		//	Node
		//	| Relationship
		//	| Path
		//	| Integer
		//	//| FloatingPoint
		//	| MyString
		//	| Bool
		//	| NullValue
		//	| List
		//	| Map;
		@Override public ParserRule getRule() { return rule; }
		
		//Node | Relationship | Path | Integer //| FloatingPoint
		//| MyString | Bool | NullValue | List | Map
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Node
		public RuleCall getNodeParserRuleCall_0() { return cNodeParserRuleCall_0; }
		
		//Relationship
		public RuleCall getRelationshipParserRuleCall_1() { return cRelationshipParserRuleCall_1; }
		
		//Path
		public RuleCall getPathParserRuleCall_2() { return cPathParserRuleCall_2; }
		
		//Integer
		public RuleCall getIntegerParserRuleCall_3() { return cIntegerParserRuleCall_3; }
		
		//MyString
		public RuleCall getMyStringParserRuleCall_4() { return cMyStringParserRuleCall_4; }
		
		//Bool
		public RuleCall getBoolParserRuleCall_5() { return cBoolParserRuleCall_5; }
		
		//NullValue
		public RuleCall getNullValueParserRuleCall_6() { return cNullValueParserRuleCall_6; }
		
		//List
		public RuleCall getListParserRuleCall_7() { return cListParserRuleCall_7; }
		
		//Map
		public RuleCall getMapParserRuleCall_8() { return cMapParserRuleCall_8; }
	}
	public class NodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.Node");
		private final RuleCall cNodeDescParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * node : nodeDesc ;
		// * / Node:
		//	NodeDesc;
		@Override public ParserRule getRule() { return rule; }
		
		//NodeDesc
		public RuleCall getNodeDescParserRuleCall() { return cNodeDescParserRuleCall; }
	}
	public class NodeDescElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.NodeDesc");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNodeDescAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLabelsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLabelsLabelParserRuleCall_2_0 = (RuleCall)cLabelsAssignment_2.eContents().get(0);
		private final Assignment cPropertyMapAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPropertyMapPropertyMapParserRuleCall_3_0 = (RuleCall)cPropertyMapAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/// *
		// * nodeDesc : '(' (label)* WS? (propertyMap)? ')' ;
		// * / NodeDesc:
		//	{NodeDesc} '(' labels+=Label* propertyMap=PropertyMap? ')';
		@Override public ParserRule getRule() { return rule; }
		
		//{NodeDesc} '(' labels+=Label* propertyMap=PropertyMap? ')'
		public Group getGroup() { return cGroup; }
		
		//{NodeDesc}
		public Action getNodeDescAction_0() { return cNodeDescAction_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//labels+=Label*
		public Assignment getLabelsAssignment_2() { return cLabelsAssignment_2; }
		
		//Label
		public RuleCall getLabelsLabelParserRuleCall_2_0() { return cLabelsLabelParserRuleCall_2_0; }
		
		//propertyMap=PropertyMap?
		public Assignment getPropertyMapAssignment_3() { return cPropertyMapAssignment_3; }
		
		//PropertyMap
		public RuleCall getPropertyMapPropertyMapParserRuleCall_3_0() { return cPropertyMapPropertyMapParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class RelationshipElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.Relationship");
		private final RuleCall cRelationshipDescParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * relationship : relationshipDesc ;
		// * / Relationship:
		//	RelationshipDesc;
		@Override public ParserRule getRule() { return rule; }
		
		//RelationshipDesc
		public RuleCall getRelationshipDescParserRuleCall() { return cRelationshipDescParserRuleCall; }
	}
	public class RelationshipDescElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.RelationshipDesc");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRelationshipDescAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeRelationshipTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Assignment cPropertyMapAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPropertyMapPropertyMapParserRuleCall_3_0 = (RuleCall)cPropertyMapAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/// *
		// * relationshipDesc : '[' relationshipType (WS propertyMap)* ']' ;
		// * / RelationshipDesc:
		//	{RelationshipDesc} '[' type=RelationshipType propertyMap=PropertyMap? ']';
		@Override public ParserRule getRule() { return rule; }
		
		//{RelationshipDesc} '[' type=RelationshipType propertyMap=PropertyMap? ']'
		public Group getGroup() { return cGroup; }
		
		//{RelationshipDesc}
		public Action getRelationshipDescAction_0() { return cRelationshipDescAction_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//type=RelationshipType
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//RelationshipType
		public RuleCall getTypeRelationshipTypeParserRuleCall_2_0() { return cTypeRelationshipTypeParserRuleCall_2_0; }
		
		//propertyMap=PropertyMap?
		public Assignment getPropertyMapAssignment_3() { return cPropertyMapAssignment_3; }
		
		//PropertyMap
		public RuleCall getPropertyMapPropertyMapParserRuleCall_3_0() { return cPropertyMapPropertyMapParserRuleCall_3_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}
	public class PathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.Path");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cPathBodyParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		/// *
		// * path : '<' pathBody '>' ;
		// * / Path:
		//	'<' PathBody '>';
		@Override public ParserRule getRule() { return rule; }
		
		//'<' PathBody '>'
		public Group getGroup() { return cGroup; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }
		
		//PathBody
		public RuleCall getPathBodyParserRuleCall_1() { return cPathBodyParserRuleCall_1; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_2() { return cGreaterThanSignKeyword_2; }
	}
	public class PathBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.PathBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNodeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNodeNodeDescParserRuleCall_0_0 = (RuleCall)cNodeAssignment_0.eContents().get(0);
		private final Assignment cPathLinksAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPathLinksPathLinkParserRuleCall_1_0 = (RuleCall)cPathLinksAssignment_1.eContents().get(0);
		
		/// *
		// * pathBody : nodeDesc (pathLink)* ;
		// * / PathBody:
		//	node=NodeDesc pathLinks+=PathLink*;
		@Override public ParserRule getRule() { return rule; }
		
		//node=NodeDesc pathLinks+=PathLink*
		public Group getGroup() { return cGroup; }
		
		//node=NodeDesc
		public Assignment getNodeAssignment_0() { return cNodeAssignment_0; }
		
		//NodeDesc
		public RuleCall getNodeNodeDescParserRuleCall_0_0() { return cNodeNodeDescParserRuleCall_0_0; }
		
		//pathLinks+=PathLink*
		public Assignment getPathLinksAssignment_1() { return cPathLinksAssignment_1; }
		
		//PathLink
		public RuleCall getPathLinksPathLinkParserRuleCall_1_0() { return cPathLinksPathLinkParserRuleCall_1_0; }
	}
	public class PathLinkElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.PathLink");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPathLinkAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cRelationshipAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRelationshipDirectedRelationshipParserRuleCall_1_0 = (RuleCall)cRelationshipAssignment_1.eContents().get(0);
		private final Assignment cNodeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNodeNodeDescParserRuleCall_2_0 = (RuleCall)cNodeAssignment_2.eContents().get(0);
		
		/// *
		// * pathLink : (forwardsRelationship | backwardsRelationship) nodeDesc ;
		// * / PathLink:
		//	{PathLink} relationship=DirectedRelationship node=NodeDesc;
		@Override public ParserRule getRule() { return rule; }
		
		//{PathLink} relationship=DirectedRelationship node=NodeDesc
		public Group getGroup() { return cGroup; }
		
		//{PathLink}
		public Action getPathLinkAction_0() { return cPathLinkAction_0; }
		
		//relationship=DirectedRelationship
		public Assignment getRelationshipAssignment_1() { return cRelationshipAssignment_1; }
		
		//DirectedRelationship
		public RuleCall getRelationshipDirectedRelationshipParserRuleCall_1_0() { return cRelationshipDirectedRelationshipParserRuleCall_1_0; }
		
		//node=NodeDesc
		public Assignment getNodeAssignment_2() { return cNodeAssignment_2; }
		
		//NodeDesc
		public RuleCall getNodeNodeDescParserRuleCall_2_0() { return cNodeNodeDescParserRuleCall_2_0; }
	}
	public class DirectedRelationshipElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.DirectedRelationship");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cForwardsRelationshipParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBackwardsRelationshipParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//DirectedRelationship:
		//	ForwardsRelationship | BackwardsRelationship;
		@Override public ParserRule getRule() { return rule; }
		
		//ForwardsRelationship | BackwardsRelationship
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ForwardsRelationship
		public RuleCall getForwardsRelationshipParserRuleCall_0() { return cForwardsRelationshipParserRuleCall_0; }
		
		//BackwardsRelationship
		public RuleCall getBackwardsRelationshipParserRuleCall_1() { return cBackwardsRelationshipParserRuleCall_1; }
	}
	public class ForwardsRelationshipElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.ForwardsRelationship");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cForwardsRelationshipAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRelationshipDescAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRelationshipDescRelationshipDescParserRuleCall_2_0 = (RuleCall)cRelationshipDescAssignment_2.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// *
		// * forwardsRelationship : '-' relationshipDesc '->' ;
		// * / ForwardsRelationship:
		//	{ForwardsRelationship} '-' relationshipDesc=RelationshipDesc '->';
		@Override public ParserRule getRule() { return rule; }
		
		//{ForwardsRelationship} '-' relationshipDesc=RelationshipDesc '->'
		public Group getGroup() { return cGroup; }
		
		//{ForwardsRelationship}
		public Action getForwardsRelationshipAction_0() { return cForwardsRelationshipAction_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
		
		//relationshipDesc=RelationshipDesc
		public Assignment getRelationshipDescAssignment_2() { return cRelationshipDescAssignment_2; }
		
		//RelationshipDesc
		public RuleCall getRelationshipDescRelationshipDescParserRuleCall_2_0() { return cRelationshipDescRelationshipDescParserRuleCall_2_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_3() { return cHyphenMinusGreaterThanSignKeyword_3; }
	}
	public class BackwardsRelationshipElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.BackwardsRelationship");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBackwardsRelationshipAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLessThanSignHyphenMinusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRelationshipDescAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRelationshipDescRelationshipDescParserRuleCall_2_0 = (RuleCall)cRelationshipDescAssignment_2.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// *
		// * backwardsRelationship : '<-' relationshipDesc '-' ;
		// * / BackwardsRelationship:
		//	{BackwardsRelationship} '<-' relationshipDesc=RelationshipDesc '-';
		@Override public ParserRule getRule() { return rule; }
		
		//{BackwardsRelationship} '<-' relationshipDesc=RelationshipDesc '-'
		public Group getGroup() { return cGroup; }
		
		//{BackwardsRelationship}
		public Action getBackwardsRelationshipAction_0() { return cBackwardsRelationshipAction_0; }
		
		//'<-'
		public Keyword getLessThanSignHyphenMinusKeyword_1() { return cLessThanSignHyphenMinusKeyword_1; }
		
		//relationshipDesc=RelationshipDesc
		public Assignment getRelationshipDescAssignment_2() { return cRelationshipDescAssignment_2; }
		
		//RelationshipDesc
		public RuleCall getRelationshipDescRelationshipDescParserRuleCall_2_0() { return cRelationshipDescRelationshipDescParserRuleCall_2_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_3() { return cHyphenMinusKeyword_3; }
	}
	public class FloatingPointElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.FloatingPoint");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cINFINITYTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//FloatingPoint:
		//	INT // TODO
		//	| INFINITY;
		@Override public ParserRule getRule() { return rule; }
		
		//INT // TODO
		//| INFINITY
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//INFINITY
		public RuleCall getINFINITYTerminalRuleCall_1() { return cINFINITYTerminalRuleCall_1; }
	}
	public class BoolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.Bool");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBoolAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cValueAlternatives_1_0 = (Alternatives)cValueAssignment_1.eContents().get(0);
		private final Keyword cValueTrueKeyword_1_0_0 = (Keyword)cValueAlternatives_1_0.eContents().get(0);
		private final Keyword cValueFalseKeyword_1_0_1 = (Keyword)cValueAlternatives_1_0.eContents().get(1);
		
		/// *
		// * bool : 'true'
		// *      | 'false'
		// *      ;
		// * / Bool:
		//	{Bool} value=('true' | 'false');
		@Override public ParserRule getRule() { return rule; }
		
		//{Bool} value=('true' | 'false')
		public Group getGroup() { return cGroup; }
		
		//{Bool}
		public Action getBoolAction_0() { return cBoolAction_0; }
		
		//value=('true' | 'false')
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//('true' | 'false')
		public Alternatives getValueAlternatives_1_0() { return cValueAlternatives_1_0; }
		
		//'true'
		public Keyword getValueTrueKeyword_1_0_0() { return cValueTrueKeyword_1_0_0; }
		
		//'false'
		public Keyword getValueFalseKeyword_1_0_1() { return cValueFalseKeyword_1_0_1; }
	}
	public class NullValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.NullValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNullValueAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNullKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		/// *
		// * nullValue : 'null' ;
		// * / NullValue:
		//	{NullValue} 'null';
		@Override public ParserRule getRule() { return rule; }
		
		//{NullValue} 'null'
		public Group getGroup() { return cGroup; }
		
		//{NullValue}
		public Action getNullValueAction_0() { return cNullValueAction_0; }
		
		//'null'
		public Keyword getNullKeyword_1() { return cNullKeyword_1; }
	}
	public class ListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.List");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cListAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cListContentsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cListContentsListContentsParserRuleCall_2_0 = (RuleCall)cListContentsAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// *
		// * list : '[' (listContents)? ']' ;
		// * / List:
		//	{List} '[' listContents=ListContents? ']';
		@Override public ParserRule getRule() { return rule; }
		
		//{List} '[' listContents=ListContents? ']'
		public Group getGroup() { return cGroup; }
		
		//{List}
		public Action getListAction_0() { return cListAction_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//listContents=ListContents?
		public Assignment getListContentsAssignment_2() { return cListContentsAssignment_2; }
		
		//ListContents
		public RuleCall getListContentsListContentsParserRuleCall_2_0() { return cListContentsListContentsParserRuleCall_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class ListContentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.ListContents");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cListContentsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cListContentsListElementParserRuleCall_0_0 = (RuleCall)cListContentsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cListContentsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cListContentsListElementParserRuleCall_1_1_0 = (RuleCall)cListContentsAssignment_1_1.eContents().get(0);
		
		/// *
		// * listContents : listElement (', ' listElement)* ;
		// * / ListContents:
		//	listContents+=ListElement (',' listContents+=ListElement)*;
		@Override public ParserRule getRule() { return rule; }
		
		//listContents+=ListElement (',' listContents+=ListElement)*
		public Group getGroup() { return cGroup; }
		
		//listContents+=ListElement
		public Assignment getListContentsAssignment_0() { return cListContentsAssignment_0; }
		
		//ListElement
		public RuleCall getListContentsListElementParserRuleCall_0_0() { return cListContentsListElementParserRuleCall_0_0; }
		
		//(',' listContents+=ListElement)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//listContents+=ListElement
		public Assignment getListContentsAssignment_1_1() { return cListContentsAssignment_1_1; }
		
		//ListElement
		public RuleCall getListContentsListElementParserRuleCall_1_1_0() { return cListContentsListElementParserRuleCall_1_1_0; }
	}
	public class ListElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.ListElement");
		private final RuleCall cFeatureValueParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * listElement : value ;
		// * / ListElement:
		//	FeatureValue;
		@Override public ParserRule getRule() { return rule; }
		
		//FeatureValue
		public RuleCall getFeatureValueParserRuleCall() { return cFeatureValueParserRuleCall; }
	}
	public class MapElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.Map");
		private final RuleCall cPropertyMapParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * map : propertyMap ;
		// * / Map:
		//	PropertyMap;
		@Override public ParserRule getRule() { return rule; }
		
		//PropertyMap
		public RuleCall getPropertyMapParserRuleCall() { return cPropertyMapParserRuleCall; }
	}
	public class PropertyMapElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.PropertyMap");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPropertyMapAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cMapContentsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMapContentsMapContentsParserRuleCall_2_0 = (RuleCall)cMapContentsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// *
		// * propertyMap : '{' (mapContents)? '}' ;
		// * / PropertyMap:
		//	{PropertyMap} '{' mapContents=MapContents? '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{PropertyMap} '{' mapContents=MapContents? '}'
		public Group getGroup() { return cGroup; }
		
		//{PropertyMap}
		public Action getPropertyMapAction_0() { return cPropertyMapAction_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//mapContents=MapContents?
		public Assignment getMapContentsAssignment_2() { return cMapContentsAssignment_2; }
		
		//MapContents
		public RuleCall getMapContentsMapContentsParserRuleCall_2_0() { return cMapContentsMapContentsParserRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class MapContentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.MapContents");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeyValuePairsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeyValuePairsKeyValuePairParserRuleCall_0_0 = (RuleCall)cKeyValuePairsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cKeyValuePairsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cKeyValuePairsKeyValuePairParserRuleCall_1_1_0 = (RuleCall)cKeyValuePairsAssignment_1_1.eContents().get(0);
		
		/// *
		// * mapContents : keyValuePair (', ' keyValuePair)* ;
		// * / MapContents:
		//	keyValuePairs+=KeyValuePair (',' keyValuePairs+=KeyValuePair)*;
		@Override public ParserRule getRule() { return rule; }
		
		//keyValuePairs+=KeyValuePair (',' keyValuePairs+=KeyValuePair)*
		public Group getGroup() { return cGroup; }
		
		//keyValuePairs+=KeyValuePair
		public Assignment getKeyValuePairsAssignment_0() { return cKeyValuePairsAssignment_0; }
		
		//KeyValuePair
		public RuleCall getKeyValuePairsKeyValuePairParserRuleCall_0_0() { return cKeyValuePairsKeyValuePairParserRuleCall_0_0; }
		
		//(',' keyValuePairs+=KeyValuePair)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//keyValuePairs+=KeyValuePair
		public Assignment getKeyValuePairsAssignment_1_1() { return cKeyValuePairsAssignment_1_1; }
		
		//KeyValuePair
		public RuleCall getKeyValuePairsKeyValuePairParserRuleCall_1_1_0() { return cKeyValuePairsKeyValuePairParserRuleCall_1_1_0; }
	}
	public class KeyValuePairElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.KeyValuePair");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeyPropertyKeyParserRuleCall_0_0 = (RuleCall)cKeyAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuePropertyValueParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		/// *
		// * keyValuePair: propertyKey ':' WS? propertyValue ;
		// * / KeyValuePair:
		//	key=PropertyKey ':' value=PropertyValue;
		@Override public ParserRule getRule() { return rule; }
		
		//key=PropertyKey ':' value=PropertyValue
		public Group getGroup() { return cGroup; }
		
		//key=PropertyKey
		public Assignment getKeyAssignment_0() { return cKeyAssignment_0; }
		
		//PropertyKey
		public RuleCall getKeyPropertyKeyParserRuleCall_0_0() { return cKeyPropertyKeyParserRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//value=PropertyValue
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//PropertyValue
		public RuleCall getValuePropertyValueParserRuleCall_2_0() { return cValuePropertyValueParserRuleCall_2_0; }
	}
	public class PropertyKeyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.PropertyKey");
		private final RuleCall cSYMBOLIC_NAMEParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * propertyKey : SYMBOLIC_NAME ;
		// * / PropertyKey:
		//	SYMBOLIC_NAME;
		@Override public ParserRule getRule() { return rule; }
		
		//SYMBOLIC_NAME
		public RuleCall getSYMBOLIC_NAMEParserRuleCall() { return cSYMBOLIC_NAMEParserRuleCall; }
	}
	public class PropertyValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.PropertyValue");
		private final RuleCall cFeatureValueParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * propertyValue : value ;
		// * / PropertyValue:
		//	FeatureValue;
		@Override public ParserRule getRule() { return rule; }
		
		//FeatureValue
		public RuleCall getFeatureValueParserRuleCall() { return cFeatureValueParserRuleCall; }
	}
	public class RelationshipTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.RelationshipType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameRelationshipTypeNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		/// *
		// * relationshipType : ':' relationshipTypeName ;
		// * / RelationshipType:
		//	':' name=RelationshipTypeName;
		@Override public ParserRule getRule() { return rule; }
		
		//':' name=RelationshipTypeName
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//name=RelationshipTypeName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//RelationshipTypeName
		public RuleCall getNameRelationshipTypeNameParserRuleCall_1_0() { return cNameRelationshipTypeNameParserRuleCall_1_0; }
	}
	public class RelationshipTypeNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.RelationshipTypeName");
		private final RuleCall cSYMBOLIC_NAMEParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * relationshipTypeName : SYMBOLIC_NAME ;
		// * / RelationshipTypeName:
		//	SYMBOLIC_NAME;
		@Override public ParserRule getRule() { return rule; }
		
		//SYMBOLIC_NAME
		public RuleCall getSYMBOLIC_NAMEParserRuleCall() { return cSYMBOLIC_NAMEParserRuleCall; }
	}
	public class LabelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.Label");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameLabelNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		/// *
		// * label : ':' labelName ;
		// * / Label:
		//	':' name=LabelName;
		@Override public ParserRule getRule() { return rule; }
		
		//':' name=LabelName
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//name=LabelName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//LabelName
		public RuleCall getNameLabelNameParserRuleCall_1_0() { return cNameLabelNameParserRuleCall_1_0; }
	}
	public class LabelNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.LabelName");
		private final RuleCall cSYMBOLIC_NAMEParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * labelName : SYMBOLIC_NAME ;
		// * / LabelName:
		//	SYMBOLIC_NAME;
		@Override public ParserRule getRule() { return rule; }
		
		//SYMBOLIC_NAME
		public RuleCall getSYMBOLIC_NAMEParserRuleCall() { return cSYMBOLIC_NAMEParserRuleCall; }
	}
	public class IntegerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.Integer");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		/// *
		// * integer : INTEGER_LITERAL ;
		// *
		// * INTEGER_LITERAL : ('-')? DECIMAL_LITERAL ;
		// *
		// * DECIMAL_LITERAL : '0'
		// *                 | NONZERODIGIT DIGIT*
		// *                 ;
		// *
		// * DIGIT : '0'
		// *       | NONZERODIGIT
		// *       ;
		// *
		// * NONZERODIGIT : [1-9] ;
		// * / Integer:
		//	value=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}
	public class EXPONENTPARTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.EXPONENTPART");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cEKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cEKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		/// *
		// * FLOAT_LITERAL : '-'? FLOAT_REPR ;
		// *
		// * FLOAT_REPR : DIGIT+ '.' DIGIT+ EXPONENTPART?
		// *            | '.' DIGIT+ EXPONENTPART?
		// *            | DIGIT EXPONENTPART
		// *            | DIGIT+ EXPONENTPART?
		// *            ;
		// * / / *
		// * EXPONENTPART :  ('E' | 'e') ('+' | '-')? DIGIT+ ; // this allows 'E06' as well - this might be intentional
		// * / EXPONENTPART:
		//	('E' | 'e') ('+' | '-')? INT;
		@Override public ParserRule getRule() { return rule; }
		
		//('E' | 'e') ('+' | '-')? INT
		public Group getGroup() { return cGroup; }
		
		//('E' | 'e')
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'E'
		public Keyword getEKeyword_0_0() { return cEKeyword_0_0; }
		
		//'e'
		public Keyword getEKeyword_0_1() { return cEKeyword_0_1; }
		
		//('+' | '-')?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_0() { return cPlusSignKeyword_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
	}
	public class SYMBOLIC_NAMEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.SYMBOLIC_NAME");
		private final RuleCall cIDENTIFIERTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		////SYMBOLIC_NAME : IDENTIFIER ;
		//SYMBOLIC_NAME:
		//	IDENTIFIER;
		@Override public ParserRule getRule() { return rule; }
		
		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall() { return cIDENTIFIERTerminalRuleCall; }
	}
	public class MyStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.MyString");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRING_LITERALTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//// The string rule should ideally not include the apostrophes in the parsed value,
		//// but a lexer rule may not match the empty string, so I haven't found a way
		//// to define that quite well yet.
		/// *
		// * string : STRING_LITERAL ;
		// * / MyString:
		//	value=STRING_LITERAL;
		@Override public ParserRule getRule() { return rule; }
		
		//value=STRING_LITERAL
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING_LITERAL
		public RuleCall getValueSTRING_LITERALTerminalRuleCall_0() { return cValueSTRING_LITERALTerminalRuleCall_0; }
	}
	
	
	private final FeatureValueElements pFeatureValue;
	private final NodeElements pNode;
	private final NodeDescElements pNodeDesc;
	private final RelationshipElements pRelationship;
	private final RelationshipDescElements pRelationshipDesc;
	private final PathElements pPath;
	private final PathBodyElements pPathBody;
	private final PathLinkElements pPathLink;
	private final DirectedRelationshipElements pDirectedRelationship;
	private final ForwardsRelationshipElements pForwardsRelationship;
	private final BackwardsRelationshipElements pBackwardsRelationship;
	private final FloatingPointElements pFloatingPoint;
	private final BoolElements pBool;
	private final NullValueElements pNullValue;
	private final ListElements pList;
	private final ListContentsElements pListContents;
	private final ListElementElements pListElement;
	private final MapElements pMap;
	private final PropertyMapElements pPropertyMap;
	private final MapContentsElements pMapContents;
	private final KeyValuePairElements pKeyValuePair;
	private final PropertyKeyElements pPropertyKey;
	private final PropertyValueElements pPropertyValue;
	private final RelationshipTypeElements pRelationshipType;
	private final RelationshipTypeNameElements pRelationshipTypeName;
	private final LabelElements pLabel;
	private final LabelNameElements pLabelName;
	private final IntegerElements pInteger;
	private final TerminalRule tINFINITY;
	private final EXPONENTPARTElements pEXPONENTPART;
	private final SYMBOLIC_NAMEElements pSYMBOLIC_NAME;
	private final TerminalRule tIDENTIFIER;
	private final MyStringElements pMyString;
	private final TerminalRule tSTRING_LITERAL;
	private final TerminalRule tSTRING_BODY;
	private final TerminalRule tESCAPED_APOSTROPHE;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public FeatureResultsGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pFeatureValue = new FeatureValueElements();
		this.pNode = new NodeElements();
		this.pNodeDesc = new NodeDescElements();
		this.pRelationship = new RelationshipElements();
		this.pRelationshipDesc = new RelationshipDescElements();
		this.pPath = new PathElements();
		this.pPathBody = new PathBodyElements();
		this.pPathLink = new PathLinkElements();
		this.pDirectedRelationship = new DirectedRelationshipElements();
		this.pForwardsRelationship = new ForwardsRelationshipElements();
		this.pBackwardsRelationship = new BackwardsRelationshipElements();
		this.pFloatingPoint = new FloatingPointElements();
		this.pBool = new BoolElements();
		this.pNullValue = new NullValueElements();
		this.pList = new ListElements();
		this.pListContents = new ListContentsElements();
		this.pListElement = new ListElementElements();
		this.pMap = new MapElements();
		this.pPropertyMap = new PropertyMapElements();
		this.pMapContents = new MapContentsElements();
		this.pKeyValuePair = new KeyValuePairElements();
		this.pPropertyKey = new PropertyKeyElements();
		this.pPropertyValue = new PropertyValueElements();
		this.pRelationshipType = new RelationshipTypeElements();
		this.pRelationshipTypeName = new RelationshipTypeNameElements();
		this.pLabel = new LabelElements();
		this.pLabelName = new LabelNameElements();
		this.pInteger = new IntegerElements();
		this.tINFINITY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.INFINITY");
		this.pEXPONENTPART = new EXPONENTPARTElements();
		this.pSYMBOLIC_NAME = new SYMBOLIC_NAMEElements();
		this.tIDENTIFIER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.IDENTIFIER");
		this.pMyString = new MyStringElements();
		this.tSTRING_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.STRING_LITERAL");
		this.tSTRING_BODY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.STRING_BODY");
		this.tESCAPED_APOSTROPHE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ingraph.cucumber.featureresult.FeatureResults.ESCAPED_APOSTROPHE");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("ingraph.cucumber.featureresult.FeatureResults".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	/// *
	// * value : node
	// *  | relationship
	// *  | path
	// *  | integer
	// *  | floatingPoint
	// *  | string
	// *  | bool
	// *  | nullValue
	// *  | list
	// *  | map
	// *  ;
	// * / // renamed 'Value' to 'FeatureValue' to disambiguate it from the Neo4j driver's org.neo4j.driver.v1.Value class
	//FeatureValue:
	//	Node
	//	| Relationship
	//	| Path
	//	| Integer
	//	//| FloatingPoint
	//	| MyString
	//	| Bool
	//	| NullValue
	//	| List
	//	| Map;
	public FeatureValueElements getFeatureValueAccess() {
		return pFeatureValue;
	}
	
	public ParserRule getFeatureValueRule() {
		return getFeatureValueAccess().getRule();
	}
	
	/// *
	// * node : nodeDesc ;
	// * / Node:
	//	NodeDesc;
	public NodeElements getNodeAccess() {
		return pNode;
	}
	
	public ParserRule getNodeRule() {
		return getNodeAccess().getRule();
	}
	
	/// *
	// * nodeDesc : '(' (label)* WS? (propertyMap)? ')' ;
	// * / NodeDesc:
	//	{NodeDesc} '(' labels+=Label* propertyMap=PropertyMap? ')';
	public NodeDescElements getNodeDescAccess() {
		return pNodeDesc;
	}
	
	public ParserRule getNodeDescRule() {
		return getNodeDescAccess().getRule();
	}
	
	/// *
	// * relationship : relationshipDesc ;
	// * / Relationship:
	//	RelationshipDesc;
	public RelationshipElements getRelationshipAccess() {
		return pRelationship;
	}
	
	public ParserRule getRelationshipRule() {
		return getRelationshipAccess().getRule();
	}
	
	/// *
	// * relationshipDesc : '[' relationshipType (WS propertyMap)* ']' ;
	// * / RelationshipDesc:
	//	{RelationshipDesc} '[' type=RelationshipType propertyMap=PropertyMap? ']';
	public RelationshipDescElements getRelationshipDescAccess() {
		return pRelationshipDesc;
	}
	
	public ParserRule getRelationshipDescRule() {
		return getRelationshipDescAccess().getRule();
	}
	
	/// *
	// * path : '<' pathBody '>' ;
	// * / Path:
	//	'<' PathBody '>';
	public PathElements getPathAccess() {
		return pPath;
	}
	
	public ParserRule getPathRule() {
		return getPathAccess().getRule();
	}
	
	/// *
	// * pathBody : nodeDesc (pathLink)* ;
	// * / PathBody:
	//	node=NodeDesc pathLinks+=PathLink*;
	public PathBodyElements getPathBodyAccess() {
		return pPathBody;
	}
	
	public ParserRule getPathBodyRule() {
		return getPathBodyAccess().getRule();
	}
	
	/// *
	// * pathLink : (forwardsRelationship | backwardsRelationship) nodeDesc ;
	// * / PathLink:
	//	{PathLink} relationship=DirectedRelationship node=NodeDesc;
	public PathLinkElements getPathLinkAccess() {
		return pPathLink;
	}
	
	public ParserRule getPathLinkRule() {
		return getPathLinkAccess().getRule();
	}
	
	//DirectedRelationship:
	//	ForwardsRelationship | BackwardsRelationship;
	public DirectedRelationshipElements getDirectedRelationshipAccess() {
		return pDirectedRelationship;
	}
	
	public ParserRule getDirectedRelationshipRule() {
		return getDirectedRelationshipAccess().getRule();
	}
	
	/// *
	// * forwardsRelationship : '-' relationshipDesc '->' ;
	// * / ForwardsRelationship:
	//	{ForwardsRelationship} '-' relationshipDesc=RelationshipDesc '->';
	public ForwardsRelationshipElements getForwardsRelationshipAccess() {
		return pForwardsRelationship;
	}
	
	public ParserRule getForwardsRelationshipRule() {
		return getForwardsRelationshipAccess().getRule();
	}
	
	/// *
	// * backwardsRelationship : '<-' relationshipDesc '-' ;
	// * / BackwardsRelationship:
	//	{BackwardsRelationship} '<-' relationshipDesc=RelationshipDesc '-';
	public BackwardsRelationshipElements getBackwardsRelationshipAccess() {
		return pBackwardsRelationship;
	}
	
	public ParserRule getBackwardsRelationshipRule() {
		return getBackwardsRelationshipAccess().getRule();
	}
	
	//FloatingPoint:
	//	INT // TODO
	//	| INFINITY;
	public FloatingPointElements getFloatingPointAccess() {
		return pFloatingPoint;
	}
	
	public ParserRule getFloatingPointRule() {
		return getFloatingPointAccess().getRule();
	}
	
	/// *
	// * bool : 'true'
	// *      | 'false'
	// *      ;
	// * / Bool:
	//	{Bool} value=('true' | 'false');
	public BoolElements getBoolAccess() {
		return pBool;
	}
	
	public ParserRule getBoolRule() {
		return getBoolAccess().getRule();
	}
	
	/// *
	// * nullValue : 'null' ;
	// * / NullValue:
	//	{NullValue} 'null';
	public NullValueElements getNullValueAccess() {
		return pNullValue;
	}
	
	public ParserRule getNullValueRule() {
		return getNullValueAccess().getRule();
	}
	
	/// *
	// * list : '[' (listContents)? ']' ;
	// * / List:
	//	{List} '[' listContents=ListContents? ']';
	public ListElements getListAccess() {
		return pList;
	}
	
	public ParserRule getListRule() {
		return getListAccess().getRule();
	}
	
	/// *
	// * listContents : listElement (', ' listElement)* ;
	// * / ListContents:
	//	listContents+=ListElement (',' listContents+=ListElement)*;
	public ListContentsElements getListContentsAccess() {
		return pListContents;
	}
	
	public ParserRule getListContentsRule() {
		return getListContentsAccess().getRule();
	}
	
	/// *
	// * listElement : value ;
	// * / ListElement:
	//	FeatureValue;
	public ListElementElements getListElementAccess() {
		return pListElement;
	}
	
	public ParserRule getListElementRule() {
		return getListElementAccess().getRule();
	}
	
	/// *
	// * map : propertyMap ;
	// * / Map:
	//	PropertyMap;
	public MapElements getMapAccess() {
		return pMap;
	}
	
	public ParserRule getMapRule() {
		return getMapAccess().getRule();
	}
	
	/// *
	// * propertyMap : '{' (mapContents)? '}' ;
	// * / PropertyMap:
	//	{PropertyMap} '{' mapContents=MapContents? '}';
	public PropertyMapElements getPropertyMapAccess() {
		return pPropertyMap;
	}
	
	public ParserRule getPropertyMapRule() {
		return getPropertyMapAccess().getRule();
	}
	
	/// *
	// * mapContents : keyValuePair (', ' keyValuePair)* ;
	// * / MapContents:
	//	keyValuePairs+=KeyValuePair (',' keyValuePairs+=KeyValuePair)*;
	public MapContentsElements getMapContentsAccess() {
		return pMapContents;
	}
	
	public ParserRule getMapContentsRule() {
		return getMapContentsAccess().getRule();
	}
	
	/// *
	// * keyValuePair: propertyKey ':' WS? propertyValue ;
	// * / KeyValuePair:
	//	key=PropertyKey ':' value=PropertyValue;
	public KeyValuePairElements getKeyValuePairAccess() {
		return pKeyValuePair;
	}
	
	public ParserRule getKeyValuePairRule() {
		return getKeyValuePairAccess().getRule();
	}
	
	/// *
	// * propertyKey : SYMBOLIC_NAME ;
	// * / PropertyKey:
	//	SYMBOLIC_NAME;
	public PropertyKeyElements getPropertyKeyAccess() {
		return pPropertyKey;
	}
	
	public ParserRule getPropertyKeyRule() {
		return getPropertyKeyAccess().getRule();
	}
	
	/// *
	// * propertyValue : value ;
	// * / PropertyValue:
	//	FeatureValue;
	public PropertyValueElements getPropertyValueAccess() {
		return pPropertyValue;
	}
	
	public ParserRule getPropertyValueRule() {
		return getPropertyValueAccess().getRule();
	}
	
	/// *
	// * relationshipType : ':' relationshipTypeName ;
	// * / RelationshipType:
	//	':' name=RelationshipTypeName;
	public RelationshipTypeElements getRelationshipTypeAccess() {
		return pRelationshipType;
	}
	
	public ParserRule getRelationshipTypeRule() {
		return getRelationshipTypeAccess().getRule();
	}
	
	/// *
	// * relationshipTypeName : SYMBOLIC_NAME ;
	// * / RelationshipTypeName:
	//	SYMBOLIC_NAME;
	public RelationshipTypeNameElements getRelationshipTypeNameAccess() {
		return pRelationshipTypeName;
	}
	
	public ParserRule getRelationshipTypeNameRule() {
		return getRelationshipTypeNameAccess().getRule();
	}
	
	/// *
	// * label : ':' labelName ;
	// * / Label:
	//	':' name=LabelName;
	public LabelElements getLabelAccess() {
		return pLabel;
	}
	
	public ParserRule getLabelRule() {
		return getLabelAccess().getRule();
	}
	
	/// *
	// * labelName : SYMBOLIC_NAME ;
	// * / LabelName:
	//	SYMBOLIC_NAME;
	public LabelNameElements getLabelNameAccess() {
		return pLabelName;
	}
	
	public ParserRule getLabelNameRule() {
		return getLabelNameAccess().getRule();
	}
	
	/// *
	// * integer : INTEGER_LITERAL ;
	// *
	// * INTEGER_LITERAL : ('-')? DECIMAL_LITERAL ;
	// *
	// * DECIMAL_LITERAL : '0'
	// *                 | NONZERODIGIT DIGIT*
	// *                 ;
	// *
	// * DIGIT : '0'
	// *       | NONZERODIGIT
	// *       ;
	// *
	// * NONZERODIGIT : [1-9] ;
	// * / Integer:
	//	value=INT;
	public IntegerElements getIntegerAccess() {
		return pInteger;
	}
	
	public ParserRule getIntegerRule() {
		return getIntegerAccess().getRule();
	}
	
	//terminal INFINITY:
	//	'-'? 'Inf';
	public TerminalRule getINFINITYRule() {
		return tINFINITY;
	}
	
	/// *
	// * FLOAT_LITERAL : '-'? FLOAT_REPR ;
	// *
	// * FLOAT_REPR : DIGIT+ '.' DIGIT+ EXPONENTPART?
	// *            | '.' DIGIT+ EXPONENTPART?
	// *            | DIGIT EXPONENTPART
	// *            | DIGIT+ EXPONENTPART?
	// *            ;
	// * / / *
	// * EXPONENTPART :  ('E' | 'e') ('+' | '-')? DIGIT+ ; // this allows 'E06' as well - this might be intentional
	// * / EXPONENTPART:
	//	('E' | 'e') ('+' | '-')? INT;
	public EXPONENTPARTElements getEXPONENTPARTAccess() {
		return pEXPONENTPART;
	}
	
	public ParserRule getEXPONENTPARTRule() {
		return getEXPONENTPARTAccess().getRule();
	}
	
	////SYMBOLIC_NAME : IDENTIFIER ;
	//SYMBOLIC_NAME:
	//	IDENTIFIER;
	public SYMBOLIC_NAMEElements getSYMBOLIC_NAMEAccess() {
		return pSYMBOLIC_NAME;
	}
	
	public ParserRule getSYMBOLIC_NAMERule() {
		return getSYMBOLIC_NAMEAccess().getRule();
	}
	
	//terminal IDENTIFIER:
	//	ID;
	public TerminalRule getIDENTIFIERRule() {
		return tIDENTIFIER;
	}
	
	//// The string rule should ideally not include the apostrophes in the parsed value,
	//// but a lexer rule may not match the empty string, so I haven't found a way
	//// to define that quite well yet.
	/// *
	// * string : STRING_LITERAL ;
	// * / MyString:
	//	value=STRING_LITERAL;
	public MyStringElements getMyStringAccess() {
		return pMyString;
	}
	
	public ParserRule getMyStringRule() {
		return getMyStringAccess().getRule();
	}
	
	//terminal STRING_LITERAL:
	//	'\'' STRING_BODY* '\'';
	public TerminalRule getSTRING_LITERALRule() {
		return tSTRING_LITERAL;
	}
	
	//terminal STRING_BODY:
	//	'\\u0000'..'\\u0026' // \\u0027 is the string delimiter character (')
	//	| '\\u0028'..'\\u01FF'
	//	| ESCAPED_APOSTROPHE;
	public TerminalRule getSTRING_BODYRule() {
		return tSTRING_BODY;
	}
	
	//terminal ESCAPED_APOSTROPHE:
	//	'\\\'';
	public TerminalRule getESCAPED_APOSTROPHERule() {
		return tESCAPED_APOSTROPHE;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
